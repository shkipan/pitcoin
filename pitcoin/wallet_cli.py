#!/usr/bin/env python

#wallet for creating transactions

import sys, os, cmd, base58, binascii
import tx_validator, pending_pool 
from transaction import Transaction
from tx_validator import *
from serializer import Serializer, Deserializer
from wallet import *
from block import Block
import json, requests
from utxo_set import *

from operator import itemgetter

import struct

from syncdata import get_config
from pathlib import Path

home = str(Path.home()) + '/.pitcoin/'
my_url, PORT = get_config()
PORT = str(PORT)

class Shell(cmd.Cmd):
    prompt = termcolors.BLUE + 'pitcoin-cli: ' + termcolors.DEF 
    intro = "Pitcoin wallet manager"

    fee = 5
    private_key = None
    public_key = None
    public_address = None
    serial = None
    raw = None

    def do_exit(self, line):
        print(termcolors.RED + 'Client stopped' + termcolors.DEF)
        sys.exit()

    def preloop(self):
 #       if os.path.isfile('mempool'):
 #           os.remove('mempool')
 #       f = open('mempool', 'a')
#        f.close
        return None

    def emptyline(self):
        return None

    def do_EOF(self, line):
        return True

    def do_converttowif(self, line):
        if (self.private_key):
            print (convert_to_wif(self.private_key))
        else:
            print ('No private key generated!')

    def do_getpublickey(self, line):
        if (self.private_key):
            s = get_public_key(self.private_key)
            print (s)
            self.public_key = s
        else:
            print ('No private key generated!')

    def do_getpublicaddress(self, line):
        if (self.private_key):
            s = get_public_address(self.private_key)
            print (s)
        else:
            print ('No private key generated!')

    def do_convertfromwif(self, line):
        if (len(line) > 0):
            s = convert_from_wif(line.split(' ')[0])
            print (s)
        else:
            print ('Enter key in WIF as an argument!')

    def do_help(self, line):
        if len(line) == 0:
            print_help()
        else:
            if line == 'balance':
                print ('Syntax: balance <address>')
                print ('Checks all blocks in blockchain and returns amount of pitcoins on passed address')
            elif line == 'broadcast':
                # ver2.0 print ('Syntax: broadcast [-f]')
                print ('Syntax: broadcast')
                print ('Sends serialized transaction to mempool.')
                print ('You must have serialized transaction generated by', termcolors.GRN, 'send', termcolors.DEF ,'command')
            elif line == 'import':
                print ('Syntax: import <file_path>')
                print ('Reads private key in WIF format from file')
            elif line == 'new':
                print ('Syntax: new')
                print ('Generates pair of private key and public address.')
                print ('Public key is stored in file called address in curr dir. Private key is stored in memory')
            elif line == 'send':
                print ('Syntax: send <recipient> <amount>')
                print ('Generates new transaction, validates it and serializes it.')
                print ('You must have private key generated by', termcolors.GRN, 'new', termcolors.DEF, 'or', termcolors.GRN, 'import', termcolors.DEF, 'command')
            elif line == 'help':
                print ('Syntax: help')
                print ('Displays help message.')
            elif line == 'exit':
                print ('Syntax: exit')
                print ('Stops wallet.')

    def default(self, line):
        print ('### Unknown command: ' + termcolors.RED + line + termcolors.DEF)
        print ('-' * len('*** Unknown command: ' + line))
        print_help()
    
    def do_new(self, line):
        privk = get_new_private_key()
        publk = get_public_key(privk)
        publaddr = get_public_address(privk)
        print ('private key:     ', convert_to_wif(privk))
        print ('public address:  ', publaddr)
        open('address', 'w+').write(publaddr)
        self.private_key = privk
        self.public_key = publk
        self.public_address = publaddr

    def do_import(self, line):
        path = line.split(' ')[0]
        try:
            wif = open(path, 'r').readline().replace('\n', '')
            self.private_key = convert_from_wif(wif)
            publk = get_public_key(self.private_key)
            publaddr = get_public_address(self.private_key)
            self.public_address = publaddr
            open('address', 'w+').write(publaddr)
            self.public_key = publk
            print ('private key:     ', convert_to_wif(self.private_key))
            print ('public address:  ', publaddr)
        except IOError:
            print ('Can\'t open file ' + path)

    def do_send(self, line):
        print ('depredecated')
        return
        if (len(line.split(' ')) < 2):
            print ('Enter recipient\'s address and amount')
        else:
            if not self.private_key:
                print ('No private key generated!')
                return
            try:
                publk = open('address', 'r').readline().replace('\n', '')
                if int(line.split(' ')[1]) > 65535 or int(line.split(' ')[1]) < 1:
                    raise ValueError()
                x = Transaction(publk, line.split(' ')[0], int(line.split(' ')[1]), None)
                x.signature, x.public_address = sign(self.private_key, x.gethash())
                if (verification(x)):
                    print (termcolors.GRN + 'Transaction verified' + termcolors.DEF)
                    self.serial = Serializer.serialize(x)
                else:
                    print (termcolors.RED + 'Transaction declined' + termcolors.DEF)
            except IOError:
                print ('Can\'t open address file')
            except ValueError:
                print (termcolors.RED + 'Error! ' + termcolors.DEF + 'Coins\' number must be integer from 1 to 65535 coins')

    def do_sendraw(self, line):
        if (len(line.split(' ')) < 2):
            print ('Enter recipient\'s address and amount')
            return 
        if not self.private_key:
            print ('No private key generated!')
            return
        sender = self.public_address
        recipient = line.split(' ')[0]
        try:
            amount = int(line.split(' ')[1])
            if amount <= 0:
                raise ValueError
        except ValueError:
            print ('Amount must be nonzero positive integer')
            return 

        unspent_outs = get_inputs(sender, my_url + ':' + PORT + '/utxo?address=' + sender) 
        if not unspent_outs:
            return
        inputs = utxo_select_inputs(unspent_outs, self.fee, amount) 
        if len(inputs) == 0:
            print ('Not enough money to perform transaction')
            return 
        outputs = utxo_create_outputs(sender, recipient, amount, self.fee, inputs)

        print ('inputs')
        print (inputs)
        print ('outputs')
        print (outputs)
        ext = {'inp': inputs, 'oup': outputs, 'locktime':0, 'version': 1}
        x = Transaction(sender, recipient, amount, ext)
        raw = Serializer.serialize_raw(x, self.private_key, self.public_key)
        print (raw.hex())
        self.raw = raw


    def do_broadraw(self, line):
        if not self.raw:
            print ('Create raw transaction with <sendraw> command!')
            return 
        send_url = my_url + ':' + str(PORT) + '/raw/new'
        data = {'serial': self.raw.hex()}
        try:
            r = requests.post(url = send_url, json=data)
        except requests.exceptions.ConnectionError:
            print ('Unable to connect')
            return 
        d = json.loads(r.text)
        try:
            if (d['success']):
                print ('Transaction is valid')
        except KeyError:
            print (d['error'] + ', transaction denied')
        self.raw = None

    def do_broadcast(self, line):
        print ('depredecated')
        return 
        testnet_flag = False
        if (len(line) != 0):
            if (line.split(' ')[0] == '-f'):
                print ('broadcasting to testnet!')
                testnet_flag = True
                return 
        if not self.serial:
            print ('Create transaction with <send> command!')
            return 
        if (pending_pool.add_trans(self.serial)):
            print ('Transaction added to mempool')
        self.serial = None

    def do_balance(self, line):
        if (len(line) > 0):
            print ('Your address is ' + line.split(' ')[0])
            send_url = my_url + ':' + PORT + '/balance'
            data = {'addr': line.split(' ')[0]}
            try:
                r = requests.get(url=send_url, json = data)
            except requests.exceptions.ConnectionError:
                print ('Unable to connect')
            d = json.loads(r.text)
            try:
                if (d['success']):
                    print ('Your utxo_balance is', d['utxo_balance'])
            except KeyError:
                print (d['error'])
        else:
            print ('Enter address to check it\'s balance!')

if __name__ == '__main__':
    try:
        Shell().cmdloop()
    except KeyboardInterrupt:
        print(termcolors.RED + '\nClient interrupted' + termcolors.DEF)
   #     if os.path.isfile('mempool'):
    #        os.remove('mempool')
        if Shell().private_key:
            Shell().private_key = None

