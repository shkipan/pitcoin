#!/usr/bin/env python

#wallet for creating transactions

import sys, os, cmd, base58, binascii
import tx_validator, pending_pool 
from transaction import Transaction, CoinbaseTransaction
from tx_validator import *
from serializer import Serializer, Deserializer
from wallet import *
from block import Block
import json, requests
from utxo_set import *

from operator import itemgetter

import struct

from syncdata import get_config
from pathlib import Path

#home = str(Path.home()) + '/.pitcoin/'
home = './.pitcoin/'

my_url, PORT = get_config()
PORT = str(PORT)

send_url = my_url + ':' + PORT 

class Shell(cmd.Cmd):
    prompt = termcolors.BLUE + 'pitcoin-cli: ' + termcolors.DEF 
    intro = "Pitcoin wallet manager"

    fee = 5
    private_key = None
    public_key = None
    public_address = None
    serial = None
    raw = None
    TOKEN = '3544fc09de684d92b42215350dfd29f3'

    def do_exit(self, line):
        print(termcolors.RED + 'Client stopped' + termcolors.DEF)
        sys.exit()

    def preloop(self):
 #       if os.path.isfile('mempool'):
 #           os.remove('mempool')
 #       f = open('mempool', 'a')
#        f.close
        return None

    def emptyline(self):
        return None

    def do_EOF(self, line):
        return True

    def do_converttowif(self, line):
        if (self.private_key):
            print (convert_to_wif(self.private_key))
        else:
            print ('No private key generated!')

    def do_getpublickey(self, line):
        if (self.private_key):
            s = get_public_key(self.private_key)
            print (s)
            self.public_key = s
        else:
            print ('No private key generated!')

    def do_getpublicaddress(self, line):
        if (self.private_key):
            s = get_public_address(self.private_key)
            print (s)
        else:
            print ('No private key generated!')

    def do_convertfromwif(self, line):
        if (len(line) > 0):
            s = convert_from_wif(line.split(' ')[0])
            print (s)
        else:
            print ('Enter key in WIF as an argument!')

    def do_help(self, line):
        if len(line) == 0:
            print_help()
        else:
            if line == 'balance':
                print ('Syntax: balance <address>')
                print ('Checks all blocks in blockchain and returns amount of pitcoins on passed address')
            elif line == 'broadcast':
                #ver2.0
                print ('Syntax: broadcast [-t]')
                print ('Sends serialized transaction to mempool. Option -f allows to push in testnet')
                print ('You must have serialized transaction generated by', termcolors.GRN, 'send', termcolors.DEF ,'command')
            elif line == 'import':
                print ('Syntax: import <file_path>')
                print ('Reads private key in WIF format from file')
            elif line == 'new':
                print ('Syntax: new')
                print ('Generates pair of private key and public address.')
                print ('Public key is stored in file called address in curr dir. Private key is stored in memory')
            elif line == 'send':
                print ('Syntax: send <recipient> <amount> [-f]')
                print ('Generates new transaction, validates it and serializes it. Option -f allows to push in testnet')
                print ('You must have private key generated by', termcolors.GRN, 'new', termcolors.DEF, 'or', termcolors.GRN, 'import', termcolors.DEF, 'command')
            elif line == 'help':
                print ('Syntax: help')
                print ('Displays help message.')
            elif line == 'exit':
                print ('Syntax: exit')
                print ('Stops wallet.')

    def default(self, line):
        print ('### Unknown command: ' + termcolors.RED + line + termcolors.DEF)
        print ('-' * len('*** Unknown command: ' + line))
        print_help()
    
    def do_new(self, line):
        privk = get_new_private_key()
        publk = get_public_key(privk)
        publaddr = get_public_address(privk)
        print ('private key:     ', convert_to_wif(privk))
        print ('public address:  ', publaddr)
        open('address', 'w+').write(publaddr)
        self.private_key = privk
        self.public_key = publk
        self.public_address = publaddr

    def do_import(self, line):
        path = line.split(' ')[0]
        try:
            wif = open(path, 'r').readline().replace('\n', '')
            self.private_key = convert_from_wif(wif)
            publk = get_public_key(self.private_key)
            publaddr = get_public_address(self.private_key)
            self.public_address = publaddr
            open('address', 'w+').write(publaddr)
            self.public_key = publk
            print ('private key:     ', convert_to_wif(self.private_key))
            print ('public address:  ', publaddr)
        except IOError:
            print ('Can\'t open file ' + path)
        except AssertionError:
            print ('Invalid string in file')
        except ValueError:
            print ('Invalid string in file')

    def do_send(self, line):
        if (len(line.split(' ')) < 2):
            print ('Enter recipient\'s address and amount')
            return 
        if not self.private_key:
            print ('No private key generated!')
            return
        sender = self.public_address
        recipient = line.split(' ')[0]
        testnet = False
        if len(line.split(' ')) > 2 and line.split(' ')[2] == '-t':
                testnet = True
        try:
            amount = int(line.split(' ')[1])
            if amount <= 0:
                raise ValueError
        except ValueError:
            print ('Amount must be nonzero positive integer')
            return 
        if (testnet):
            print ('testnet')
            unspent_outs = get_testnet_inputs(sender)
        else:
            unspent_outs = get_inputs(sender, my_url + ':' + PORT + '/utxo?address=' + sender) 
        if len(unspent_outs) == 0:
            print ('Not enough money to perform transaction')
            return 
        inputs = utxo_select_inputs(unspent_outs, self.fee, amount) 
        if len(inputs) == 0:
            print ('Not enough money to perform transaction')
            return 
        outputs = utxo_create_outputs(sender, recipient, amount, self.fee, inputs)
        print ('inputs')
        print (inputs)
        print ('outputs')
        print (outputs)
        x = Transaction(sender, recipient, amount, {'inp': inputs, 'oup': outputs, 'locktime':0, 'version': 1})
        try:
            raw = Serializer.serialize_raw(x, self.private_key, self.public_key)
        except ValueError:
            print ('Invalid recipient\'s address!')
            return
        print (raw.hex())
        self.raw = raw

    def do_broadcast(self, line):
        if not self.raw:
            print ('Create raw transaction with <send> command!')
            return 
        testnet = False
        if len(line) > 0:
            if line.split(' ')[0] == '-t':
                testnet = True
        if (testnet):
            print ('Testnet broadcast inited')
            send_url = 'https://chain.so/api/v2/send_tx/BTCTEST'
            data = {'tx_hex': self.raw.hex()}
            try:
                r = requests.post(url = send_url, json=data)
            except requests.exceptions.ConnectionError:
                print ('Unable to connect')
                return False 
            d = json.loads(r.text)
            print ('Broadcast finished with', d['status'])
            if d['status']:
                print ('Transaction info')
                print (d)
            return 
        if (pending_pool.save_to_mem(self.raw.hex())):
            print ('Transaction added to mempool')

        self.raw = None

    def do_balance(self, line):
        if (len(line) > 0):
            print ('Your address is ' + line.split(' ')[0])
#            if (len(line) > 1):
#                if line.split(' ')[1] == '-t'
            send_url = my_url + ':' + PORT + '/balance'
            data = {'addr': line.split(' ')[0]}
            r = ''
            try:
                r = requests.get(url=send_url, json = data)
            except requests.exceptions.ConnectionError:
                print ('Unable to connect')
            d = json.loads(r.text)
            try:
                if (d['success']):
                    print ('Your utxo_balance is', d['utxo_balance'])
            except KeyError:
                print (d['error'])
        else:
            print ('Enter address to check it\'s balance!')

    def premine(self, reward):
        print ('premine')
        privkey = [get_new_private_key() for i in range(3)]
        addr = [get_public_address(privkey[i]) for i in range(3)]
        for i in range(len(privkey)):
            item = privkey[i]
            with open('premine' + str(i), 'w+') as f:
                f.write(convert_to_wif(item))
     #       print (item, addr[i])
    
        print ('cb creating')
        for i in addr:
            cbtrans = CoinbaseTransaction(i, reward)
            cbtrans_serial = Serializer.serialize_raw(cbtrans, '', '').hex()
            print(cbtrans_serial)
            data = {'miner': cbtrans_serial}
            try:
                r  = requests.post(url = send_url+ '/blocks/new', json=data)
            except requests.exceptions.ConnectionError:
                print ('Unable to connect')
                return False
            d = json.loads(r.text)
            try:
                if (d['success']):
                    print ('block accepted, hash:\n' + d['block']['hash'])
            except KeyError:
                print (d['error'] + ', block declined')


            print (cb_serial)
    
        print ('cb done')
        self.do_exit('')

if __name__ == '__main__':
    if len(sys.argv) > 1 and sys.argv[1] == 'premine':
        Shell().premine(1)
    try:
        Shell().cmdloop()
    except KeyboardInterrupt:
        print(termcolors.RED + '\nClient interrupted' + termcolors.DEF)
   #     if os.path.isfile('mempool'):
    #        os.remove('mempool')
        if Shell().private_key:
            Shell().private_key = None

